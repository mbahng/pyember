from typing import List, Callable, Union, overload

class BaseTensor:
    storage_: List[float]
    shape_: List[int]
    
    def type(self) -> str: ...
    def dtype(self) -> str: ...
    def shape(self) -> List[int]: ...
    def data(self) -> List[float]: ...
    def reshape(self, new_shape: List[int]) -> 'BaseTensor': ...
    def at(self, indices: List[int]) -> float: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: 'BaseTensor') -> bool: ... # type: ignore
    def __ne__(self, other: 'BaseTensor') -> bool: ... # type: ignore

class GradTensor(BaseTensor):
    pivot_: int
    
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, data: List[float], shape: List[int], pivot: int) -> None: ...
    @overload
    def __init__(self, shape: List[int], pivot: int) -> None: ...
    
    def pivot(self) -> int: ...
    @staticmethod
    def eye(n: int, pivot: int = 1) -> 'GradTensor': ...
    
    def copy(self) -> 'GradTensor': ...
    def add(self, other: Union['GradTensor', 'Tensor']) -> Union['GradTensor', 'Tensor']: ...
    def sub(self, other: Union['GradTensor', 'Tensor']) -> Union['GradTensor', 'Tensor']: ...
    def mul(self, other: Union['GradTensor', 'Tensor']) -> Union['GradTensor', 'Tensor']: ...
    def matmul(self, other: 'GradTensor') -> 'GradTensor': ...

class Tensor(BaseTensor):
    grad: GradTensor
    prev: List['Tensor']
    backward: Callable[[], None]
    
    @overload
    def __init__(self, data: List[float], shape: List[int]) -> None: ...
    @overload
    def __init__(self, data: List[float]) -> None: ...
    @overload
    def __init__(self, data: List[List[float]]) -> None: ...
    @overload
    def __init__(self, data: List[List[List[float]]]) -> None: ...
    
    @staticmethod
    def arange(start: int, stop: int, step: int = 1) -> 'Tensor': ...
    @staticmethod
    def linspace(start: float, stop: float, numsteps: int) -> 'Tensor': ...
    @staticmethod
    def gaussian(shape: List[int], mean: float = 0.0, stddev: float = 1.0) -> 'Tensor': ...
    @staticmethod
    def uniform(shape: List[int], min: float = 0.0, max: float = 1.0) -> 'Tensor': ...
    @staticmethod
    def ones(shape: List[int]) -> 'Tensor': ...
    @staticmethod
    def zeros(shape: List[int]) -> 'Tensor': ...
    
    def reshape(self, new_shape: List[int]) -> 'Tensor': ...
    def copy(self) -> 'Tensor': ...
    def backprop(self, intermediate: bool = False) -> List['Tensor']: ...
    
    def add(self, other: Union[GradTensor, 'Tensor']) -> 'Tensor': ...
    def sub(self, other: Union[GradTensor, 'Tensor']) -> 'Tensor': ...
    def mul(self, other: Union[GradTensor, 'Tensor']) -> 'Tensor': ...
    def matmul(self, other: 'Tensor') -> 'Tensor': ...
    def sum(self) -> 'Tensor': ...

