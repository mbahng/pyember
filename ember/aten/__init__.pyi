from typing import List, Callable, overload, Any, Union

class BaseTensor:
  storage: List[float]
  shape: List[int] 
  bidx: int
  
  def type(self) -> str: ...
  def dtype(self) -> str: ...
  def data(self) -> List[float]: ...
  def reshape(self, new_shape: List[int]) -> 'BaseTensor': ...
  def __getitem__(self, indices: Any): ...
  def __setitem__(self, indices: Any, value: Union[float, BaseTensor]): ...

  def __str__(self) -> str: ...
  def __repr__(self) -> str: ...
  def __eq__(self, other: object) -> bool: ... 
  def __ne__(self, other: object) -> bool: ... 

class GradTensor(BaseTensor):
  bidx: int
  
  @overload
  def __init__(self) -> None: ...
  @overload
  def __init__(self, data: List[float], shape: List[int], pivot: int) -> None: ...
  @overload
  def __init__(self, shape: List[int], pivot: int) -> None: ...

  @staticmethod
  def eye(n: int, pivot: int = 1) -> 'GradTensor': ...
  
  def copy(self) -> 'GradTensor': ...
  def transpose(self, indices: List[int]) -> 'GradTensor': ...

  def __neg__(self) -> 'GradTensor': ... 

  @overload
  def __add__(self, other: 'GradTensor') -> 'GradTensor': ... 
  @overload
  def __add__(self, other: float) -> 'Tensor': ... 
  @overload
  def __add__(self, other: 'Tensor') -> 'Tensor': ... 

  @overload
  def __sub__(self, other: 'GradTensor') -> 'GradTensor': ... 
  @overload
  def __sub__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __sub__(self, other: float) -> 'GradTensor': ... 
  def __rsub__(self, other: float) -> 'GradTensor': ... 

  @overload
  def __mul__(self, other: 'GradTensor') -> 'GradTensor': ... 
  @overload
  def __mul__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __mul__(self, other: float) -> 'GradTensor': ... 

  def matmul(self, other: 'GradTensor') -> 'GradTensor': ...

class Tensor(BaseTensor):
  grad: GradTensor
  prev: List['Tensor']
  backward: Callable[[], None] 
  has_grad: bool
  
  @overload
  def __init__(self, data: List[float], shape: List[int]) -> None: ...
  @overload
  def __init__(self, data: List[float]) -> None: ...
  @overload
  def __init__(self, data: List[List[float]]) -> None: ...
  @overload
  def __init__(self, data: List[List[List[float]]]) -> None: ...
  
  @staticmethod
  def arange(start: int, stop: int, step: int = 1) -> 'Tensor': ...
  @staticmethod
  def linspace(start: float, stop: float, numsteps: int) -> 'Tensor': ...
  @staticmethod
  def gaussian(
    shape: List[int], 
    mean: float = 0.0, 
    stddev: float = 1.0, 
    bidx: int = 0, 
    has_grad: bool = True
  ) -> 'Tensor': ...
  @staticmethod
  def uniform(
    shape: List[int], 
    min: float = 0.0, 
    max: float = 1.0, 
    bidx: int = 0, 
    has_grad: bool = True
  ) -> 'Tensor': ...
  @staticmethod
  def ones(shape: List[int]) -> 'Tensor': ...
  @staticmethod
  def zeros(shape: List[int]) -> 'Tensor': ...
  
  def reshape(self, new_shape: List[int]) -> 'Tensor': ...
  def transpose(self, indices: List[int]) -> 'Tensor': ...
  def copy(self) -> 'Tensor': ...
  def backprop(self, intermediate: bool = False) -> List['Tensor']: ...

  def __neg__(self) -> 'Tensor': ... 
  
  @overload
  def __add__(self, other: 'ScalarTensor') -> 'Tensor': ... 
  @overload
  def __add__(self, other: 'GradTensor') -> 'Tensor': ... 
  @overload
  def __add__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __add__(self, other: float) -> 'Tensor': ... 

  @overload
  def __sub__(self, other: 'ScalarTensor') -> 'Tensor': ... 
  @overload
  def __sub__(self, other: 'GradTensor') -> 'Tensor': ... 
  @overload
  def __sub__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __sub__(self, other: float) -> 'Tensor': ... 

  @overload
  def __mul__(self, other: 'ScalarTensor') -> 'Tensor': ... 
  @overload
  def __mul__(self, other: 'GradTensor') -> 'Tensor': ... 
  @overload
  def __mul__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __mul__(self, other: float) -> 'Tensor': ...  

  def __pow__(self, exp: float) -> "Tensor": ...

  def matmul(self, other: 'Tensor') -> 'Tensor': ...
  def __matmul__(self, other: 'Tensor') -> 'Tensor': ...

  def sum(self) -> 'Tensor': ... 
  def relu(self)-> 'Tensor': ...
  def dot(self, other: 'Tensor') -> 'Tensor': ...

class ScalarTensor(Tensor): 
  @overload 
  def __init__(self, data: float) -> None: ... 
  @overload 
  def __init__(self, data: List[float]) -> None: ... 
